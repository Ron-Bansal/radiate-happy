diff --git a/app/reel/page.jsx b/app/reel/page.jsx
index 95e536c70b71d57eaf0c820d3ecaf4f497be7413..c6b7379cb0c0541453af69fa3982d97973749ea9 100644
--- a/app/reel/page.jsx
+++ b/app/reel/page.jsx
@@ -1,43 +1,104 @@
 "use client";
 
 import React, { useEffect, useRef, useState } from "react";
 import * as THREE from "three";
 
 export default function ScrollFedReel() {
   const sceneRef = useRef(null);
   const [isHudOpen, setIsHudOpen] = useState(false);
 
   useEffect(() => {
     // ===== Globals & constants
     let mode = "reel";
     let isAnimating = false;
 
     const SEGMENTS = 600;
     const SLIDE_W = 0.84;
     const SLIDE_H = 0.52;
-    const slideCount = 14;
+
+    // Seed some movies / shows for the reel
+    const watched = [
+      { title: "Superman", year: 2025, type: "movie" },
+      { title: "Thunderbolts", year: 2025, type: "movie" },
+      { title: "Spirited Away", year: 2001, type: "movie" },
+      { title: "The Ba***ds of Bollywood", year: null, type: "tv" },
+      { title: "Nobody", year: 2021, type: "movie" },
+      { title: "Nobody 2", year: 2025, type: "movie" },
+      { title: "A Nice Indian Boy", year: null, type: "movie" },
+      { title: "The Paper", year: null, type: "movie" },
+      { title: "Virgin Island", year: null, type: "movie" },
+      { title: "Ocean’s Twelve", year: 2004, type: "movie" },
+      { title: "Friendship", year: null, type: "movie" },
+      { title: "Dept Q", year: null, type: "tv" },
+      { title: "Adults", year: null, type: "tv" },
+      { title: "Mountainhead", year: null, type: "movie" },
+      { title: "Common Side Effects", year: null, type: "tv" },
+      { title: "Avatar: The Way of Water", year: 2022, type: "movie" },
+      { title: "Death of a Unicorn", year: null, type: "movie" },
+      { title: "The Iron Claw", year: 2023, type: "movie" },
+      { title: "Novocaine", year: null, type: "movie" },
+      { title: "Mickey 17", year: 2025, type: "movie" },
+      { title: "Adolescence", year: null, type: "movie" },
+      { title: "DanDaDan", year: 2024, type: "tv" },
+      { title: "Derry Girls", year: 2018, type: "tv" },
+      { title: "I Don't Understand You", year: null, type: "movie" },
+      { title: "The Rookie", year: 2018, type: "tv" },
+      { title: "The Studio", year: null, type: "tv" },
+      { title: "Bob’s Burgers", year: 2011, type: "tv" },
+      { title: "It's Always Sunny in Philadelphia", year: 2005, type: "tv" },
+      { title: "Conan O'Brien Must Go", year: 2024, type: "tv" },
+      { title: "In the Know", year: 2024, type: "tv" },
+      { title: "Late Bloomer", year: 2024, type: "tv" },
+      { title: "Normal People", year: 2020, type: "tv" },
+      { title: "Scavengers Reign", year: 2023, type: "tv" },
+      { title: "BoJack Horseman", year: 2014, type: "tv" },
+      {
+        title: "Heavenly Delusion (Tengoku Daimakyo)",
+        year: 2023,
+        type: "tv",
+      },
+      { title: "The Midnight Gospel", year: 2020, type: "tv" },
+      { title: "Kim’s Convenience", year: 2016, type: "tv" },
+      { title: "Vinland Saga", year: 2019, type: "tv" },
+      { title: "Baki", year: 2018, type: "tv" },
+      { title: "Alice in Borderland", year: 2020, type: "tv" },
+      { title: "Ghosts", year: 2019, type: "tv" },
+      { title: "Dark", year: 2017, type: "tv" },
+      { title: "Malcolm in the Middle", year: 2000, type: "tv" },
+      { title: "Fleabag", year: 2016, type: "tv" },
+      { title: "Interview with the Vampire", year: 2022, type: "tv" },
+      { title: "Peacemaker", year: 2022, type: "tv" },
+      { title: "Gen V", year: 2023, type: "tv" },
+      { title: "Dexter", year: 2006, type: "tv" },
+      { title: "Platonic", year: 2023, type: "tv" },
+      { title: "Bolt", year: 2008, type: "movie" },
+    ];
+    const slideCount = watched.length;
+    let gridScroll = 0;
+    let gridScrollVelocity = 0;
+    let gridScrollBounds = { min: 0, max: 0 };
 
     // ===== Background
     const body = document.body;
     function hexToRgb(hex) {
       hex = hex.replace("#", "");
       if (hex.length === 3) {
         hex = hex
           .split("")
           .map((c) => c + c)
           .join("");
       }
       const num = parseInt(hex, 16);
       return { r: (num >> 16) & 255, g: (num >> 8) & 255, b: num & 255 };
     }
     function setRadialBg(hex) {
       const rgb = hexToRgb(hex);
       body.style.background =
         "radial-gradient(circle at 50% 35%, rgba(" +
         rgb.r +
         "," +
         rgb.g +
         "," +
         rgb.b +
         ",0.18), rgba(" +
         rgb.r +
diff --git a/app/reel/page.jsx b/app/reel/page.jsx
index 95e536c70b71d57eaf0c820d3ecaf4f497be7413..c6b7379cb0c0541453af69fa3982d97973749ea9 100644
--- a/app/reel/page.jsx
+++ b/app/reel/page.jsx
@@ -231,280 +292,409 @@ export default function ScrollFedReel() {
       return { p: p1, T, N: Nu, B };
     }
 
     // ===== Controls (query by id to keep parity)
     const twistsEl = document.getElementById("twists");
     const radiusEl = document.getElementById("radius");
     const pitchEl = document.getElementById("pitch");
     const tiltEl = document.getElementById("tilt");
     const stripWidthEl = document.getElementById("stripWidth");
     const stripLengthEl = document.getElementById("stripLength");
     const frameSpacingEl = document.getElementById("frameSpacing");
     const stripOpacityEl = document.getElementById("stripOpacity");
     const textureStrengthEl = document.getElementById("textureStrength");
     const uprSpreadEl = document.getElementById("uprightSpread");
     const uprTopEl = document.getElementById("uprTop");
     const uprBotEl = document.getElementById("uprBot");
     const radTopEl = document.getElementById("radTop");
     const radBotEl = document.getElementById("radBot");
     const feedRatioEl = document.getElementById("feedRatio");
     const reverseDirectionEl = document.getElementById("reverseDirection");
     const reverseOrderEl = document.getElementById("reverseOrder");
 
     if (reverseDirectionEl) {
       reverseDirectionEl.addEventListener("change", function () {
         updateGeometry(scrollProgress());
+        refreshScrollSpace();
       });
     }
 
+    [stripLengthEl, frameSpacingEl].forEach((el) => {
+      if (!el) return;
+      el.addEventListener("input", refreshScrollSpace);
+    });
+
     // ===== Storage for curve frames
     const P = new Array(SEGMENTS + 1);
     const BX = new Array(SEGMENTS + 1);
     const NX = new Array(SEGMENTS + 1);
     const TX = new Array(SEGMENTS + 1);
 
+    let stripPlacement = {
+      start: 0,
+      step: slideCount > 1 ? 1 / slideCount : 0,
+      totalSpan: slideCount > 1 ? (slideCount - 1) / slideCount : 0,
+      rangeMin: 0,
+      rangeMax: 1,
+    };
+
+    function sampleStripFrame(t) {
+      const span = stripPlacement.rangeMax - stripPlacement.rangeMin;
+      if (span <= 0) {
+        const fallback = {
+          pos: P[0] ? P[0].clone() : new THREE.Vector3(),
+          bx: BX[0] ? BX[0].clone() : new THREE.Vector3(1, 0, 0),
+          nx: NX[0] ? NX[0].clone() : new THREE.Vector3(0, 1, 0),
+          tx: TX[0] ? TX[0].clone() : new THREE.Vector3(0, 0, 1),
+        };
+        return fallback;
+      }
+      const normalized = (t - stripPlacement.rangeMin) / span;
+      const clamped = Math.min(1, Math.max(0, normalized));
+      const exact = clamped * SEGMENTS;
+      const idx0 = Math.floor(exact);
+      const idx1 = Math.min(SEGMENTS, idx0 + 1);
+      const alpha = exact - idx0;
+      const p0 = P[idx0] || P[0] || new THREE.Vector3();
+      const p1 = P[idx1] || p0;
+      const b0 = BX[idx0] || BX[0] || new THREE.Vector3(1, 0, 0);
+      const b1 = BX[idx1] || b0;
+      const n0 = NX[idx0] || NX[0] || new THREE.Vector3(0, 1, 0);
+      const n1 = NX[idx1] || n0;
+      const t0 = TX[idx0] || TX[0] || new THREE.Vector3(0, 0, 1);
+      const t1 = TX[idx1] || t0;
+      return {
+        pos: p0.clone().lerp(p1, alpha),
+        bx: b0.clone().lerp(b1, alpha),
+        nx: n0.clone().lerp(n1, alpha),
+        tx: t0.clone().lerp(t1, alpha),
+      };
+    }
+
     function updateGeometry(scroll) {
       const reverse = !!(reverseDirectionEl && reverseDirectionEl.checked);
       const STRIP_LEN = parseFloat(stripLengthEl.value);
       const offsetAmount = 0.15;
       const effectiveScroll = reverse
         ? scroll - offsetAmount
         : 1 - scroll + offsetAmount;
       const phase = effectiveScroll * Math.PI * 4;
       const turns = phase / (Math.PI * 2);
       const feedRatio = parseFloat((feedRatioEl && feedRatioEl.value) || 0);
       const paramShift = (feedRatio * turns) % 1;
       const twists = parseFloat(twistsEl.value);
       const baseR = parseFloat(radiusEl.value);
       const pitch = parseFloat(pitchEl.value);
       const stripW = parseFloat(stripWidthEl.value);
       const halfW = stripW / 2;
       let v = 0,
         u = 0;
       const uprSpread = parseFloat(uprSpreadEl.value);
       const uprTop = THREE.MathUtils.degToRad(parseFloat(uprTopEl.value || 0));
       const uprBot = THREE.MathUtils.degToRad(parseFloat(uprBotEl.value || 0));
       const radTop = parseFloat(radTopEl.value || 0);
       const radBot = parseFloat(radBotEl.value || 0);
+      const spacingInput = parseFloat(frameSpacingEl && frameSpacingEl.value) || 1;
+      const spacingFactor = 0.4 + spacingInput * 1.1;
+      const safeCount = Math.max(1, slideCount);
+      const base = 1 / safeCount;
+      const step = slideCount > 1 ? base * spacingFactor : 0;
+      const totalSpan = step * Math.max(0, slideCount - 1);
+      const start = slideCount > 1 ? 0.5 * (1 - totalSpan) : 0;
+      const spanExcess = Math.max(0, totalSpan - 1);
+      const leadPadBase = 0.12 + spanExcess * 0.15;
+      const trailPadBase = 0.34 + spanExcess * 0.3;
+      const leadPad = reverse ? leadPadBase : trailPadBase;
+      const trailPad = reverse ? trailPadBase : leadPadBase;
+      const rangeMin = start - leadPad;
+      const rangeMax = start + totalSpan + trailPad;
+      const rangeSpan = rangeMax - rangeMin || 1;
+
+      stripPlacement = {
+        start,
+        step,
+        totalSpan,
+        rangeMin,
+        rangeMax,
+      };
 
       for (let i = 0; i <= SEGMENTS; i++) {
         const t = i / SEGMENTS;
-        const tRaw = t + paramShift;
+        const tNorm = rangeMin + (rangeSpan * i) / SEGMENTS;
+        const tRaw = tNorm + paramShift;
         const tShift = tRaw % 1;
-        const yApprox = (tShift - 0.5) * STRIP_LEN * (pitch / 2);
+        const wrappedShift = tShift < 0 ? tShift + 1 : tShift;
+        const yApprox = (wrappedShift - 0.5) * STRIP_LEN * (pitch / 2);
         const topBias = 0.5 + 0.5 * Math.tanh(yApprox * 1.2);
         const radiusEff = baseR + topBias * radTop + (1 - topBias) * radBot;
         const p1 = helixAt(tRaw, phase, radiusEff, pitch, twists, STRIP_LEN);
         const p2 = helixAt(
           tRaw + 1e-3,
           phase,
           radiusEff,
           pitch,
           twists,
           STRIP_LEN
         );
         const f = frameFromPos(p1, p2);
         const centerFalloff = 1.0 - Math.min(1, Math.abs(t - 0.5) * 2.0);
         const softened = centerFalloff * 0.5 + 0.5;
         const weight = uprSpread * 0.5 + (1.0 - uprSpread) * softened;
         const uprightTheta =
           (uprTop * topBias + uprBot * (1 - topBias)) * weight;
         const ct = Math.cos(uprightTheta),
           st = Math.sin(uprightTheta);
         const Bx = f.B.clone().multiplyScalar(ct).addScaledVector(f.N, st);
         const Nx = f.N.clone().multiplyScalar(ct).addScaledVector(f.B, -st);
 
         P[i] = f.p;
         BX[i] = Bx;
         NX[i] = Nx;
         TX[i] = f.T;
         const L = f.p.clone().addScaledVector(Bx, -halfW);
         const R = f.p.clone().addScaledVector(Bx, +halfW);
         verts[v++] = L.x;
         verts[v++] = L.y;
         verts[v++] = L.z;
         verts[v++] = R.x;
         verts[v++] = R.y;
         verts[v++] = R.z;
-        const vv = t * 10.0;
+        const vv = ((tNorm - rangeMin) / rangeSpan) * 10.0;
         uvs[u++] = 0;
         uvs[u++] = vv;
         uvs[u++] = 1;
         uvs[u++] = vv;
       }
       geom.attributes.position.needsUpdate = true;
       geom.attributes.uv.needsUpdate = true;
       geom.computeVertexNormals();
 
       if (mode !== "reel" || isAnimating) return;
 
       const railFrac = 0.22;
       const windowH = stripW * (1 - 2 * railFrac);
       const frameH = windowH * 1.32;
       const maxW = stripW * 0.96;
-      const base = 1 / slideCount;
-      const factor = parseFloat(frameSpacingEl.value);
-      const step = Math.min(base * factor, 0.98 / (slideCount - 1));
-      const totalSpan = step * (slideCount - 1);
-      const start = 0.5 * (1 - totalSpan);
 
       for (let i = 0; i < slides.length; i++) {
-        const tt = start + i * step;
-        const idxi = Math.max(0, Math.min(SEGMENTS, Math.round(tt * SEGMENTS)));
-        const pos = P[idxi],
-          bx = BX[idxi],
-          nx = NX[idxi],
-          tx = TX[idxi];
+        const tt = stripPlacement.start + i * stripPlacement.step;
+        const frame = sampleStripFrame(tt);
+        const { pos, bx, nx, tx } = frame;
         slides[i].position.copy(pos.clone().addScaledVector(nx, 0.02));
         const angle = -Math.PI / 2,
           cA = Math.cos(angle),
           sA = Math.sin(angle);
         const bxr = bx.clone().multiplyScalar(cA).addScaledVector(tx, sA);
         const txr = tx.clone().multiplyScalar(cA).addScaledVector(bx, -sA);
         const basis = new THREE.Matrix4().makeBasis(bxr, txr, nx);
         slides[i].setRotationFromMatrix(basis);
         const asp = slideAspect(slides[i]);
         const frameW = Math.min(frameH * asp, maxW);
         slides[i].scale.set(frameW / SLIDE_W, frameH / SLIDE_H, 1);
       }
     }
 
     function onResize() {
       renderer.setSize(window.innerWidth, window.innerHeight);
       camera.aspect = window.innerWidth / window.innerHeight;
       camera.updateProjectionMatrix();
+      refreshScrollSpace();
+      const layout = gridTargets(gridScroll);
+      gridScrollBounds = layout.bounds;
+      gridScroll = layout.scroll;
+      if (mode === "grid" && !isAnimating) {
+        applySlideTargets(layout.targets);
+      }
     }
     window.addEventListener("resize", onResize);
+    refreshScrollSpace();
+    updateGeometry(scrollProgress());
 
     function scrollProgress() {
       const sp = document.querySelector(".scrollspace");
       const max = (sp ? sp.offsetHeight : 0) - window.innerHeight;
       return Math.min(1, Math.max(0, window.scrollY / Math.max(1, max)));
     }
 
+    function refreshScrollSpace() {
+      const sp = document.querySelector(".scrollspace");
+      if (!sp) return;
+      const stripLen = parseFloat((stripLengthEl && stripLengthEl.value) || 14);
+      const spacingInput = parseFloat((frameSpacingEl && frameSpacingEl.value) || 1);
+      const spacingFactor = 0.4 + spacingInput * 1.1;
+      const perFrame = 210 * spacingFactor;
+      const baseHeight =
+        window.innerHeight * 1.8 + stripLen * 140 + slides.length * perFrame;
+      const heightPx = Math.max(window.innerHeight * 4, baseHeight);
+      sp.style.height = `${Math.round(heightPx)}px`;
+      const leadBufferBase = window.innerHeight * 0.9;
+      const trailBufferBase =
+        window.innerHeight * (1.35 + Math.min(spacingFactor, 3) * 0.25);
+      const reverse = !!(reverseDirectionEl && reverseDirectionEl.checked);
+      const padTop = reverse ? leadBufferBase : trailBufferBase;
+      const padBottom = reverse ? trailBufferBase : leadBufferBase;
+      sp.style.paddingTop = `${Math.round(padTop)}px`;
+      sp.style.paddingBottom = `${Math.round(padBottom)}px`;
+    }
+
     function tick() {
       const s = scrollProgress();
       const op = parseFloat((stripOpacityEl && stripOpacityEl.value) || 1);
       filmMat.opacity = Math.min(op, 1.0);
       const strength = parseFloat(
         (textureStrengthEl && textureStrengthEl.value) || 1
       );
       const railBoost = op > 1 ? Math.min(op, 5.0) : 1;
       filmMat.color.setScalar(
         Math.max(0.0, Math.min(3.0, strength * railBoost))
       );
       reelGroup.rotation.x = THREE.MathUtils.degToRad(parseFloat(tiltEl.value));
-      updateGeometry(s);
+
+      if (mode === "grid") {
+        if (!isAnimating) {
+          gridScroll += gridScrollVelocity;
+          gridScrollVelocity *= 0.9;
+          if (Math.abs(gridScrollVelocity) < 1e-4) gridScrollVelocity = 0;
+          const gridLayout = gridTargets(gridScroll);
+          gridScrollBounds = gridLayout.bounds;
+          if (gridLayout.scroll !== gridScroll) {
+            gridScroll = gridLayout.scroll;
+            gridScrollVelocity *= -0.35;
+            if (Math.abs(gridScrollVelocity) < 1e-4) gridScrollVelocity = 0;
+          }
+          applySlideTargets(gridLayout.targets);
+        }
+      } else {
+        updateGeometry(s);
+      }
+
       renderer.render(scene, camera);
       requestAnimationFrame(tick);
     }
     tick();
 
     // ===== Reel/Grid animation helpers
-    function gridTargets() {
+    function gridTargets(scrollValue = gridScroll) {
       const cols = Math.max(2, Math.floor(window.innerWidth / 260));
       const d = 3.2;
       const fov = THREE.MathUtils.degToRad(camera.fov);
       const h = 2 * d * Math.tan(fov / 2);
       const w = h * camera.aspect;
       const cellW = (w / cols) * 0.75;
       const cellH = cellW * 1.2;
       const rows = Math.ceil(slides.length / cols);
       const startX = -w / 2 + cellW / 2;
       const startY = ((rows - 1) * cellH) / 2;
 
+      const viewTop = h / 2;
+      const viewBottom = -h / 2;
+      const slack = cellH * 1.35;
+      const margin = cellH * 0.55;
+      let minScroll = viewTop - margin - startY - slack;
+      let maxScroll = viewBottom + margin + startY + slack;
+      if (maxScroll < minScroll) {
+        const mid = (minScroll + maxScroll) / 2;
+        minScroll = mid;
+        maxScroll = mid;
+      }
+      const clampedScroll = THREE.MathUtils.clamp(
+        scrollValue,
+        minScroll,
+        maxScroll
+      );
+
       const forward = new THREE.Vector3();
       camera.getWorldDirection(forward).normalize();
       const right = forward
         .clone()
         .cross(new THREE.Vector3(0, 1, 0))
         .normalize();
       const up = new THREE.Vector3(0, 1, 0);
 
       reelGroup.updateMatrixWorld(true);
       const parentQuat = reelGroup.getWorldQuaternion(new THREE.Quaternion());
       const invParent = parentQuat.clone().invert();
 
       const targets = [];
       for (let i = 0; i < slides.length; i++) {
         const r = Math.floor(i / cols),
           c = i % cols;
         const x = startX + c * cellW,
-          y = startY - r * cellH,
+          y = startY - r * cellH + clampedScroll,
           z = -d;
         const camSpace = new THREE.Vector3(x, y, z);
         const world = camSpace.clone().applyMatrix4(camera.matrixWorld);
         const localPos = world.clone();
         reelGroup.worldToLocal(localPos);
 
         const asp = slideAspect(slides[i]);
         let fw = cellH * asp;
         let fh = cellH;
         if (fw > cellW) {
           fw = cellW;
           fh = fw / asp;
         }
         const fit = 0.88;
         fw *= fit;
         fh *= fit;
 
         const basis = new THREE.Matrix4().makeBasis(
           right,
           up,
           forward.clone().negate()
         );
         const worldQuat = new THREE.Quaternion().setFromRotationMatrix(basis);
         const localQuat = worldQuat.clone().premultiply(invParent);
 
         targets.push({
           pos: localPos,
           quat: localQuat,
           scale: new THREE.Vector3(fw / SLIDE_W, fh / SLIDE_H, 1),
         });
       }
-      return targets;
+      return {
+        targets,
+        bounds: { min: minScroll, max: maxScroll },
+        scroll: clampedScroll,
+      };
     }
 
+    const initialGrid = gridTargets(gridScroll);
+    gridScrollBounds = initialGrid.bounds;
+    gridScroll = initialGrid.scroll;
+
     function stripTargets() {
       const stripW = parseFloat(stripWidthEl.value);
       const railFrac = 0.22;
       const windowH = stripW * (1 - 2 * railFrac);
       const frameH = windowH * 1.32;
       const maxW = stripW * 0.96;
-      const base = 1 / slideCount;
-      const factor = parseFloat(frameSpacingEl.value);
-      const step = Math.min(base * factor, 0.98 / (slideCount - 1));
-      const totalSpan = step * (slideCount - 1);
-      const start = 0.5 * (1 - totalSpan);
       const targs = [];
       for (let i = 0; i < slides.length; i++) {
-        const tt = start + i * step;
-        const idxi = Math.max(0, Math.min(SEGMENTS, Math.round(tt * SEGMENTS)));
-        const pos = P[idxi],
-          bx = BX[idxi],
-          nx = NX[idxi],
-          tx = TX[idxi];
+        const tt = stripPlacement.start + i * stripPlacement.step;
+        const frame = sampleStripFrame(tt);
+        const { pos, bx, nx, tx } = frame;
         const angle = -Math.PI / 2,
           cA = Math.cos(angle),
           sA = Math.sin(angle);
         const bxr = bx.clone().multiplyScalar(cA).addScaledVector(tx, sA);
         const txr = tx.clone().multiplyScalar(cA).addScaledVector(bx, -sA);
         const m = new THREE.Matrix4().makeBasis(bxr, txr, nx);
         const quat = new THREE.Quaternion().setFromRotationMatrix(m);
         const asp = slideAspect(slides[i]);
         const frameW = Math.min(frameH * asp, maxW);
         targs.push({
           pos: pos.clone().addScaledVector(nx, 0.02),
           quat: quat,
           scale: new THREE.Vector3(frameW / SLIDE_W, frameH / SLIDE_H, 1),
         });
       }
       return targs;
     }
 
     function tweenSlides(toTargets, ms) {
       if (!ms) ms = 750;
       isAnimating = true;
       const starts = slides.map((s) => ({
         pos: s.position.clone(),
         quat: s.quaternion.clone(),
         scale: s.scale.clone(),
diff --git a/app/reel/page.jsx b/app/reel/page.jsx
index 95e536c70b71d57eaf0c820d3ecaf4f497be7413..c6b7379cb0c0541453af69fa3982d97973749ea9 100644
--- a/app/reel/page.jsx
+++ b/app/reel/page.jsx
@@ -512,66 +702,97 @@ export default function ScrollFedReel() {
       const t0 = performance.now();
       function ease(t) {
         return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
       }
       function step() {
         const t = Math.min(1, (performance.now() - t0) / ms);
         const e = ease(t);
         for (let i = 0; i < slides.length; i++) {
           slides[i].position.lerpVectors(starts[i].pos, toTargets[i].pos, e);
           slides[i].quaternion.slerpQuaternions(
             starts[i].quat,
             toTargets[i].quat,
             e
           );
           slides[i].scale.lerpVectors(starts[i].scale, toTargets[i].scale, e);
         }
         if (t < 1) {
           requestAnimationFrame(step);
         } else {
           isAnimating = false;
         }
       }
       requestAnimationFrame(step);
     }
 
+    function applySlideTargets(toTargets) {
+      for (let i = 0; i < slides.length; i++) {
+        slides[i].position.copy(toTargets[i].pos);
+        slides[i].quaternion.copy(toTargets[i].quat);
+        slides[i].scale.copy(toTargets[i].scale);
+      }
+    }
+
+    function onGridWheel(e) {
+      if (mode !== "grid") return;
+      if (typeof e.preventDefault === "function") e.preventDefault();
+      const speed = 0.0015;
+      gridScrollVelocity += e.deltaY * 0.00075;
+      gridScroll += e.deltaY * speed;
+      if (gridScroll < gridScrollBounds.min) {
+        gridScroll = gridScrollBounds.min;
+        gridScrollVelocity *= 0.35;
+      } else if (gridScroll > gridScrollBounds.max) {
+        gridScroll = gridScrollBounds.max;
+        gridScrollVelocity *= 0.35;
+      }
+    }
+
+    window.addEventListener("wheel", onGridWheel, { passive: false });
+
     function switchToGrid() {
       if (mode === "grid") return;
       setModeButtons("grid");
       mode = "grid";
       const sp = document.querySelector(".scrollspace");
       if (sp) sp.style.display = "none";
       filmMesh.visible = false;
-      tweenSlides(gridTargets(), 750);
+      const grid = gridTargets(gridScroll);
+      gridScrollBounds = grid.bounds;
+      gridScroll = grid.scroll;
+      gridScrollVelocity = 0;
+      tweenSlides(grid.targets, 750);
     }
     function switchToReel() {
       if (mode === "reel") return;
       setModeButtons("reel");
       mode = "reel";
       const sp = document.querySelector(".scrollspace");
       if (sp) sp.style.display = "";
       filmMesh.visible = true;
+      gridScrollVelocity = 0;
+      refreshScrollSpace();
       tweenSlides(stripTargets(), 750);
     }
     if (btnGrid) btnGrid.addEventListener("click", switchToGrid);
     if (btnReel) btnReel.addEventListener("click", switchToReel);
 
     // ===== Public image helpers
     const loader = new THREE.TextureLoader();
     loader.crossOrigin = "anonymous";
     const maxAniso =
       (renderer.capabilities.getMaxAnisotropy &&
         renderer.capabilities.getMaxAnisotropy()) ||
       1;
 
     function setSlide(index, url) {
       if (index < 0 || index >= slides.length || !url) return;
       loader.load(
         url,
         function (t) {
           t.anisotropy = maxAniso;
           slides[index].material.map = t;
           slides[index].material.needsUpdate = true;
         },
         undefined,
         function () {
           /* ignore */
diff --git a/app/reel/page.jsx b/app/reel/page.jsx
index 95e536c70b71d57eaf0c820d3ecaf4f497be7413..c6b7379cb0c0541453af69fa3982d97973749ea9 100644
--- a/app/reel/page.jsx
+++ b/app/reel/page.jsx
@@ -918,129 +1139,50 @@ export default function ScrollFedReel() {
         n.className = "provider";
         n.textContent = "Provider lookup failed";
         container.appendChild(n);
       }
       el.style.display = "block";
     }
 
     function hoverLoop() {
       requestAnimationFrame(hoverLoop);
       if (!window.__bindSlideMeta || !window.__getReelCamera) return;
       const slides = window.__bindSlideMeta();
       const camera = window.__getReelCamera();
       if (!camera) return;
       raycaster.setFromCamera(mouse, camera);
       const hit = raycaster.intersectObjects(slides, false)[0]?.object || null;
       if (hovered === hit) return;
       if (hovered) hovered.scale.multiplyScalar(1 / 1.04);
       hovered = hit;
       if (hovered) hovered.scale.multiplyScalar(1.04);
     }
     hoverLoop();
 
     addEventListener("mousemove", onPointerMove);
     addEventListener("click", onClick);
 
-    // Seed some movies
-    // let watched = [
-    //   { title: "Oppenheimer", year: 2023, type: "movie" },
-    //   { title: "Barbie", year: 2023, type: "movie" },
-    //   {
-    //     title: "Spider-Man: Across the Spider-Verse",
-    //     year: 2023,
-    //     type: "movie",
-    //   },
-    //   { title: "The Holdovers", year: 2023, type: "movie" },
-    //   { title: "Dune: Part Two", year: 2024, type: "movie" },
-    //   { title: "Poor Things", year: 2023, type: "movie" },
-    //   { title: "Everything Everywhere All at Once", year: 2022, type: "movie" },
-    //   { title: "Top Gun: Maverick", year: 2022, type: "movie" },
-    //   { title: "The Batman", year: 2022, type: "movie" },
-    //   { title: "The Bear", year: 2022, type: "tv" },
-    //   { title: "Succession", year: 2018, type: "tv" },
-    //   { title: "Severance", year: 2022, type: "tv" },
-    //   { title: "The Last of Us", year: 2023, type: "tv" },
-    //   { title: "Andor", year: 2022, type: "tv" },
-    // ];
-
-    let watched = [
-        { title: "Superman", year: 2025, type: "movie" },
-        { title: "Thunderbolts", year: 2025, type: "movie" },
-        { title: "Spirited Away", year: 2001, type: "movie" },
-        { title: "The Ba***ds of Bollywood", year: null, type: "tv" },
-        { title: "Nobody", year: 2021, type: "movie" },
-        { title: "Nobody 2", year: 2025, type: "movie" },
-        { title: "A Nice Indian Boy", year: null, type: "movie" },
-        { title: "The Paper", year: null, type: "movie" },
-        { title: "Virgin Island", year: null, type: "movie" },
-        { title: "Ocean’s Twelve", year: 2004, type: "movie" },
-        { title: "Friendship", year: null, type: "movie" },
-        { title: "Dept Q", year: null, type: "tv" },
-        { title: "Adults", year: null, type: "tv" },
-        { title: "Mountainhead", year: null, type: "movie" },
-        { title: "Common Side Effects", year: null, type: "tv" },
-        { title: "Avatar: The Way of Water", year: 2022, type: "movie" },
-        { title: "Death of a Unicorn", year: null, type: "movie" },
-        { title: "The Iron Claw", year: 2023, type: "movie" },
-        { title: "Novocaine", year: null, type: "movie" },
-        { title: "Mickey 17", year: 2025, type: "movie" },
-        { title: "Adolescence", year: null, type: "movie" },
-        { title: "DanDaDan", year: 2024, type: "tv" },
-        { title: "Derry Girls", year: 2018, type: "tv" },
-        { title: "I Don't Understand You", year: null, type: "movie" },
-        { title: "The Rookie", year: 2018, type: "tv" },
-        { title: "The Studio", year: null, type: "tv" },
-        { title: "Bob’s Burgers", year: 2011, type: "tv" },
-        { title: "It's Always Sunny in Philadelphia", year: 2005, type: "tv" },
-        { title: "Conan O'Brien Must Go", year: 2024, type: "tv" },
-        { title: "In the Know", year: 2024, type: "tv" },
-        { title: "Late Bloomer", year: 2024, type: "tv" },
-        { title: "Normal People", year: 2020, type: "tv" },
-        { title: "Scavengers Reign", year: 2023, type: "tv" },
-        { title: "BoJack Horseman", year: 2014, type: "tv" },
-        {
-          title: "Heavenly Delusion (Tengoku Daimakyo)",
-          year: 2023,
-          type: "tv",
-        },
-        { title: "The Midnight Gospel", year: 2020, type: "tv" },
-        { title: "Kim’s Convenience", year: 2016, type: "tv" },
-        { title: "Vinland Saga", year: 2019, type: "tv" },
-        { title: "Baki", year: 2018, type: "tv" },
-        { title: "Alice in Borderland", year: 2020, type: "tv" },
-        { title: "Ghosts", year: 2019, type: "tv" },
-        { title: "Dark", year: 2017, type: "tv" },
-        { title: "Malcolm in the Middle", year: 2000, type: "tv" },
-        { title: "Fleabag", year: 2016, type: "tv" },
-        { title: "Interview with the Vampire", year: 2022, type: "tv" },
-        { title: "Peacemaker", year: 2022, type: "tv" },
-        { title: "Gen V", year: 2023, type: "tv" },
-        { title: "Dexter", year: 2006, type: "tv" },
-        { title: "Platonic", year: 2023, type: "tv" },
-        { title: "Bolt", year: 2008, type: "movie" },
-      ];
-
     function getOrderedWatched() {
       const reverseOrder = document.getElementById("reverseOrder");
       return reverseOrder && reverseOrder.checked
         ? watched
         : [...watched].reverse();
     }
 
     if (TMDB.TMDB_ENABLED) {
       loadPostersToReel(getOrderedWatched());
     } else {
       loadDemoPosters();
     }
 
     const reverseOrderEl2 = document.getElementById("reverseOrder");
     if (reverseOrderEl2) {
       reverseOrderEl2.addEventListener("change", function () {
         if (TMDB.TMDB_ENABLED) {
           loadPostersToReel(getOrderedWatched());
         } else {
           loadDemoPosters();
         }
       });
     }
 
     // === Diagnostics & tests ===
diff --git a/app/reel/page.jsx b/app/reel/page.jsx
index 95e536c70b71d57eaf0c820d3ecaf4f497be7413..c6b7379cb0c0541453af69fa3982d97973749ea9 100644
--- a/app/reel/page.jsx
+++ b/app/reel/page.jsx
@@ -1257,51 +1399,51 @@ export default function ScrollFedReel() {
             id="stripWidth"
             type="range"
             min="0.6"
             max="2.4"
             step="0.01"
             defaultValue="1.1"
           />
         </label>
         <label>
           Strip Length (padding at ends){" "}
           <input
             id="stripLength"
             type="range"
             min="12"
             max="20"
             step="0.5"
             defaultValue="14"
           />
         </label>
         <label>
           Frame Spacing (center-to-center){" "}
           <input
             id="frameSpacing"
             type="range"
             min="0.5"
-            max="2.0"
+            max="4.0"
             step="0.01"
             defaultValue="1.00"
           />
         </label>
         <label>
           Strip Opacity{" "}
           <input
             id="stripOpacity"
             type="range"
             min="0"
             max="5"
             step="0.01"
             defaultValue="1.25"
           />
         </label>
         <label>
           Texture Strength{" "}
           <input
             id="textureStrength"
             type="range"
             min="0.3"
             max="2.5"
             step="0.01"
             defaultValue="1.10"
           />
diff --git a/app/reel/page.jsx b/app/reel/page.jsx
index 95e536c70b71d57eaf0c820d3ecaf4f497be7413..c6b7379cb0c0541453af69fa3982d97973749ea9 100644
--- a/app/reel/page.jsx
+++ b/app/reel/page.jsx
@@ -1371,51 +1513,51 @@ export default function ScrollFedReel() {
       <div className="debug-fab" id="debugFab">
         🧪
       </div>
       <div className="hud-debug" id="hudDebug">
         <div style={{ fontWeight: 700 }}>Diagnostics</div>
         <div className="tests" id="testsBox"></div>
         <div style={{ display: "flex", gap: 8, marginTop: 6 }}>
           <button id="btnRunTests">Run tests</button>
           <button id="btnDemoPosters">Load demo posters</button>
         </div>
       </div>
 
       {/* Styles */}
       <style jsx global>{`
         html,
         body {
           height: 100%;
           margin: 0;
         }
         #scene {
           position: fixed;
           inset: 0;
           z-index: 1;
         }
         .scrollspace {
-          height: 600vh;
+          min-height: 600vh;
         }
         .pill {
           position: fixed;
           top: 12px;
           left: 50%;
           transform: translateX(-50%);
           background: #fff8;
           padding: 6px 12px;
           border-radius: 999px;
           font-size: 13px;
           z-index: 2;
         }
         .swatch {
           display: inline-block;
           width: 18px;
           height: 18px;
           border-radius: 50%;
           border: 1px solid #0001;
           margin-right: 6px;
           cursor: pointer;
         }
         .mode-group {
           position: fixed;
           top: 12px;
           right: 12px;
